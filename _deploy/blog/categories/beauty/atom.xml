<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: beauty | Practical Elegance]]></title>
  <link href="http://decomplecting.org/blog/categories/beauty/atom.xml" rel="self"/>
  <link href="http://decomplecting.org/"/>
  <updated>2012-10-31T15:38:37-04:00</updated>
  <id>http://decomplecting.org/</id>
  <author>
    <name><![CDATA[Jason Lewis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simplicity]]></title>
    <link href="http://decomplecting.org/blog/2012/05/08/simplicity/"/>
    <updated>2012-05-08T10:15:00-04:00</updated>
    <id>http://decomplecting.org/blog/2012/05/08/simplicity</id>
    <content type="html"><![CDATA[<h3>Machine Beauty</h3>

<p><img class="float-left" src="http://photo.goodreads.com/books/1171573120l/107615.jpg" width="250"></p>

<p>In his essay <a href="http://www.goodreads.com/book/show/107615.Machine_Beauty">Machine Beauty</a>, David Gelernter defines "machine beauty" as an inspired mating of simplicity and power. In software, I think this is also what we mean when we talk about "elegance."</p>

<p>The Dijkstra quote that serves as a tagline for this blog is actually truncated; the full quote reads:</p>

<blockquote><p>Elegance is not a dispensable luxury but a quality that decides between success and failure.</p></blockquote>

<p>This is not (necessarily) an economic truth; few people would describe any product from Microsoft as elegant, but they have been economically successful. However, the painful experience of using Microsoft software, the unreliability of both systems and applications, the general clunkiness of Windows applications, indicates that the software here is indeed a failure.</p>

<p>Software is a failure when it becomes an obstacle to productivity rather than an aid to it; when you must serve the compiler (or interpreter) rather than the compiler serving you (think Java boilerplate). From an end-user standpoint, the failure comes when the interface imposes unnatural workflows and ceremony that interrupts the natural flow of completing a task.</p>

<p>Software is successful when you hardly notice it's there; when it becomes a natural extension of the self, an augmentation to human ability. In terms of systems, think of the Macintosh when it was introduced; nothing before had been so intuitive, and enabling. In terms of programming languages, Ruby leaps immediately to mind. It is so expressive that it no longer feels like "coding"; you are just expressing your thoughts in a syntax that feels almost immediately as natural as a spoken language.</p>

<!-- more -->


<h3>Simplicity Matters</h3>

<p>One of the most interesting (inspiring?) talks at <a href="http://railsconf2012.com/">RailsConf</a> this year was Rich Hickey's keynote entitled "Simplicity Matters". Here's the video, you should watch it:</p>

<iframe width="560" height="315" src="http://www.youtube-nocookie.com/embed/rI8tNMsozo0" frameborder="0" allowfullscreen></iframe>


<p>One of the most important points he makes, early on in the talk, is that we often tend to conflate "simple" with "easy," and this is far from accurate. It's all too easy to complect the design of languages, systems, and applications, rather than maintain simplicity and elegance. He's kind of (allusively) hard on Rails, but not without reason. One of the ongoing efforts in the refactoring and continued development of Rails is to simplify the codebase as well as the APIs.</p>

<h3>Practical Elegance</h3>

<p>There are two modern programming languages that I think exemplify the marriage of power and simplicity that constitutes elegance. The first, which I use every day, is Ruby.</p>

<p>For instance, consider the following accumulator generator in C++:</p>

<p>``` c++ Accumulator Generator http://www.paulgraham.com/accgen.html</p>

<p>template<typename T>
struct Acc {
  Acc(T n)
  : n(n) {}</p>

<p>  template<typename U>
  Acc(const Acc<U>&amp; u)
  : n(u.n) {}</p>

<p>  template<typename U>
  T operator()(U i) {</p>

<pre><code>return n += i;
</code></pre>

<p>  }</p>

<p>  T n;
};</p>

<p>```</p>

<p>Super clear, right? Readable? Oh, yeah.</p>

<p>Hardly. But maybe it's not fair to pick on C++, simplicity was (sadly) never a design goal.
Python is a more modern programming language, it's designed to be easy for new programmers to learn.</p>

<p>``` python Accumulator Generator http://www.paulgraham.com/accgen.html</p>

<p>class foo:
  def <strong>init</strong>(self, n):</p>

<pre><code>self.n = n
</code></pre>

<p>  def <strong>call</strong>(self, i):</p>

<pre><code>self.n += i
return self.n
</code></pre>

<p>```</p>

<p>Simpler than C++, sure. But you still have all these explicit calls to self, and a class definition that should be unnecessary in a functional construct like an accumulator generator. It's an improvement, but still ugly as hell.</p>

<p>Now let's look at Ruby:</p>

<p>``` ruby Accumulator Generator http://www.paulgraham.com/accgen.html</p>

<p>def foo (n)
  lambda {|i| n += i }
end</p>

<p>```</p>

<p>Wow. Three lines of code (although it could be written in one). If you understand lambdas, it's obvious what's going on here at a glance. You initalize <code>foo</code> with a value, and it returns a lambda that will accumulate any values passed to it.</p>

<p>Ruby makes the solution completely obvious.</p>

<p><em>Note: all examples above from <a href="http://www.paulgraham.com/accgen.html">Paul Graham's website</a></em></p>

<h3>Clojure</h3>

<p>The other language that has me in awe of its marriage of power and simplicity is <a href="http://clojure.org">Clojure</a>. Clojure is a Lisp dialect targeting the JVM, and I encourage anyone out there to explore it. Here's the above construct in Clojure:</p>

<p>``` clojure Accumulator Generator</p>

<p>(defn accum [n]
  (let [acc (atom n)]</p>

<pre><code>(fn [m] (swap! acc + m))))
</code></pre>

<p>```</p>

<p>Anyhow, it's a little less immediately obvious than in a language like Python or Ruby (or, for that matter, Lisps like Scheme or Common Lisp). Why is this? As I mentioned previously, Clojure, while technically an "impure" functional language (as in, side-effects are allowed), tries to treat side-effects as a special case; so, for instance, most data structures in Clojure are immutable. The <code>atom</code> construct in Clojure creates a reference type that can access shared, independent, mutable state. The <code>swap!</code> function allows the value of the atom to be updated.</p>

<p>"Wait," you might exclaim, "that seems harder to work with! Aren't immutable data structures introducing complexity!?!?"</p>

<p>Clearly, if you share this opinion, you've never tried to deal with concurrency. Clojure's preference for immutable data structures isn't <em>easier</em> than the usual acceptance of side-effects; but it is <em>simpler.</em> Making me think before I do an operation for side-effects in effect makes me think hard about many cases where I have an opportunity to complect my code.</p>

<p>I've heard the argument that Python's bondage-and-discipline approach to programmer freedom is comparable, but I call shenanigans. It's too much to go into here, but I think another day I'll go into everything that's wrong with "The Zen of Python."</p>

<p>Anyhow... I thought these preliminary thoughts on what simplicity really means would be a good start for a blog entitled <em>Practical Elegance.</em></p>
]]></content>
  </entry>
  
</feed>
